#!/usr/bin/env python3

"""nixos-hosts update manager.

Manages updates to the nixos-hosts and dotfiles repo; easily
pulls/builds/switches/pushes from those repositories.
"""


import argparse
import os
import sys
from inspect import getdoc
from pathlib import Path
from subprocess import call, check_output
from typing import Optional


def main():
    """Main entrypoint."""
    parser = argparse.ArgumentParser(prog="system-update")
    parser.add_argument(
        "--nixos-hosts",
        default=nixos_hosts(),
        type=Path,
        help="The path to the local nixos-hosts repository.",
    )
    parser.add_argument(
        "--dotfiles",
        default=dotfiles(),
        type=Path,
        help="The path to the local dotfiles repository.",
    )
    subparsers = parser.add_subparsers()

    pull_command = subparsers.add_parser(
        "pull", help=docsummary(pull), description=getdoc(pull)
    )
    pull_command.add_argument(
        "branch",
        nargs="?",
        default="origin/master",
        help="The branch from which to pull.",
    )
    pull_command.set_defaults(func=pull)

    switch_command = subparsers.add_parser(
        "switch", help=docsummary(switch), description=getdoc(switch)
    )
    switch_command.set_defaults(func=switch)

    boot_command = subparsers.add_parser(
        "boot", help=docsummary(boot), description=getdoc(boot)
    )
    boot_command.set_defaults(func=boot)

    log_command = subparsers.add_parser(
        "log", help=docsummary(log), description=getdoc(log)
    )
    log_command.add_argument(
        "branch",
        nargs="?",
        default="origin/bot/update",
        help="The branch whose updates to show.",
    )
    log_command.set_defaults(func=log)

    push_command = subparsers.add_parser(
        "push", help=docsummary(push), description=getdoc(push)
    )
    push_command.add_argument(
        "branch",
        nargs="?",
        default="origin/bot/update",
        help="The branch from which to push to master.",
    )
    push_command.set_defaults(func=push)

    args = parser.parse_args()
    if hasattr(args, "func"):
        sys.exit(args.func(args))
    else:
        parser.print_usage(sys.stderr)
        sys.exit(1)


def pull(args: argparse.Namespace) -> int:
    """Pull remote updates to the dotfiles/nixos-hosts repo.

    Local changes will be persisted via stash + rebase. If conflicts
    occur, those need to be manually resolved.
    """

    conflict = False
    stashed = False
    for repo in (args.nixos_hosts, args.dotfiles):
        call(["git", "fetch", "origin"], cwd=repo)

        # If there have been no updates upstream, we want to exit
        # before doing anything destructive.
        if check_output(["git", "rev-list", "-1", f"..{args.branch}"], cwd=repo) == b"":
            print(f"No upstream changes to {repo}.")
            continue

        # Otherwise, check if we have uncommitted changes, and stash
        # them if we do.
        if call(["git", "diff", "--quiet", "HEAD"], cwd=repo) != 0:
            call(
                [
                    "git",
                    "stash",
                    "push",
                    "--include-untracked",
                    "--message",
                    "Pre-update state",
                ],
                cwd=repo,
            )
            stashed = True

        code = call(["git", "rebase", args.branch], cwd=repo)
        if code == 0:
            print(f"Successfully rebased {repo}")
        else:
            print(f"Failed to rebase {repo} with exit code {code}")
            conflict = True

    if stashed:
        print(
            "\033[93m"  # Yellow
            "Uncommitted changes were stashed. "
            "You should pop those stashes before building."
            "\033[00m"
        )
    if conflict:
        print(
            "\033[93m"  # Red
            "Changes did not apply cleanly and created conflicts. "
            "These must be resolved."
            "\033[00m"
        )

    return 1 if conflict else 0


def switch(args: argparse.Namespace) -> int:
    """Switch to the new nixos configuration."""
    return call(
        [
            "nixos-rebuild",
            "--use-remote-sudo",  # Work around https://github.com/NixOS/nix/issues/6443
            "--override-input",
            "dotfiles",
            args.dotfiles,
            "--flake",
            str(args.nixos_hosts) + "#",
            "switch",
        ]
    )


def boot(args: argparse.Namespace) -> int:
    """Switch to the new nixos configuration on next boot."""
    return call(
        [
            "nixos-rebuild",
            "--use-remote-sudo",  # Work around https://github.com/NixOS/nix/issues/6443
            "--override-input",
            "dotfiles",
            args.dotfiles,
            "--flake",
            str(args.nixos_hosts) + "#",
            "boot",
        ]
    )


def log(args: argparse.Namespace) -> int:
    """Show the commits that would be part of the update."""
    failure = False
    for repo in (args.nixos_hosts, args.dotfiles):
        print(f"\033[4;32m{repo}:\033[00m")  # Green and underlined
        if call(["git", "log", f"..{args.branch}"], cwd=repo) != 0:
            failure = True
        print()
    return 1 if failure else 0


def push(args: argparse.Namespace) -> int:
    """Push the new state to the remote repositories.

    This will *not* push local changes, only persisting the commits
    that were also in the upstream branch.
    """
    failure = False
    for repo in (args.nixos_hosts, args.dotfiles):
        if (
            call(
                [
                    "git",
                    "push",
                    "origin",
                    f"{args.branch}:refs/heads/master",
                ],
                cwd=repo,
            )
            != 0
        ):
            failure = True
    return 1 if failure else 0


def nixos_hosts() -> Path:
    """Return the path to the nixos-hosts repository."""
    config = Path(os.environ.get("XDG_CONFIG_HOME", "~/.config")) / "user-dirs.dirs"

    documents = None
    if config.exists():
        lines = config.read_text().splitlines()

        for line in lines:
            if line.startswith("XDG_DOCUMENTS_DIR"):
                # Line example is:
                # XDG_DOCUMENTS_DIR="/home/tlater/Documents"
                documents = Path(line.split("=")[1][1:-1])

    if not documents:
        # Assume an English system with default paths by default.
        documents = Path.home() / "Documents"

    return documents / "Projects" / "nixos-hosts"


def dotfiles() -> Path:
    """Return the path to the dotfiles repository."""
    user_local = Path(os.environ.get("XDG_DATA_HOME", "~/.config")).parent
    return user_local / "src" / "dotfiles"


def docsummary(obj: object) -> Optional[str]:
    """Return the first line of an object's documentation string."""
    doc = getdoc(obj)
    if doc:
        return doc.splitlines()[0]

    return None


if __name__ == "__main__":
    main()
